// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//go:build !wireinject
// +build !wireinject

package inject

import (
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/catalog"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/config"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/managers"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/manifests"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/prometheus"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/runnables"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/utils/reconcileutils"
	"github.com/redhat-marketplace/redhat-marketplace-operator/v2/pkg/utils/rhmotransport"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/kubernetes"
	"sigs.k8s.io/controller-runtime/pkg/cache"
)

// Injectors from wire.go:

func initializeInjectDependencies(cache2 cache.Cache, fields *managers.ControllerFields) (injectorDependencies, error) {
	runnablesRunnables := runnables.ProvideRunnables()
	client := fields.Client
	scheme := fields.Scheme
	logger := fields.Logger
	clientCommandRunner := reconcileutils.NewClientCommand(client, scheme, logger)
	clientCommandInjector := &ClientCommandInjector{
		Fields:        fields,
		CommandRunner: clientCommandRunner,
	}
	restConfig := fields.Config
	restMapper, err := managers.NewDynamicRESTMapper(restConfig)
	if err != nil {
		return injectorDependencies{}, err
	}
	simpleClient, err := managers.ProvideSimpleClient(restConfig, restMapper, scheme)
	if err != nil {
		return injectorDependencies{}, err
	}
	discoveryClient, err := discovery.NewDiscoveryClientForConfig(restConfig)
	if err != nil {
		return injectorDependencies{}, err
	}
	operatorConfig, err := config.ProvideInfrastructureAwareConfig(simpleClient, discoveryClient)
	if err != nil {
		return injectorDependencies{}, err
	}
	operatorConfigInjector := &OperatorConfigInjector{
		Config: operatorConfig,
	}
	patchInjector := &PatchInjector{}
	deployedNamespace := ProvideNamespace(operatorConfig)
	factory := manifests.NewFactory(operatorConfig, scheme)
	factoryInjector := &FactoryInjector{
		Fields:    fields,
		Config:    operatorConfig,
		Namespace: deployedNamespace,
		Scheme:    scheme,
		Factory:   factory,
	}
	clientset, err := kubernetes.NewForConfig(restConfig)
	if err != nil {
		return injectorDependencies{}, err
	}
	kubeInterfaceInjector := &KubeInterfaceInjector{
		KubeInterface: clientset,
	}
	authBuilderConfig := rhmotransport.ProvideAuthBuilder(client, operatorConfig, clientset, logger)
	catalogClient, err := catalog.ProvideCatalogClient(authBuilderConfig, operatorConfig, logger)
	if err != nil {
		return injectorDependencies{}, err
	}
	catalogClientInjector := &CatalogClientInjector{
		CatalogClient: catalogClient,
	}
	prometheusAPIBuilder := &prometheus.PrometheusAPIBuilder{
		CC:  clientCommandRunner,
		Cfg: operatorConfig,
	}
	prometheusAPIBuilderInjector := &PrometheusAPIBuilderInjector{
		PrometheusAPIBuilder: prometheusAPIBuilder,
	}
	injectables := ProvideInjectables(clientCommandInjector, operatorConfigInjector, patchInjector, factoryInjector, kubeInterfaceInjector, catalogClientInjector, prometheusAPIBuilderInjector)
	injectInjectorDependencies := injectorDependencies{
		Runnables:   runnablesRunnables,
		Injectables: injectables,
	}
	return injectInjectorDependencies, nil
}

func initializeCommandRunner(fields *managers.ControllerFields) (reconcileutils.ClientCommandRunner, error) {
	client := fields.Client
	scheme := fields.Scheme
	logger := fields.Logger
	clientCommandRunner := reconcileutils.NewClientCommand(client, scheme, logger)
	return clientCommandRunner, nil
}
